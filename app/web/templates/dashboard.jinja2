{% extends "_layout.jinja2" %}
{% block content %}
<h2>Welcome to the Multi-Domain Edge Manager!</h2>

<!-- Publish Button -->
<div class="action-buttons">
    <a href="{{ url_for('view_publish') }}" class="btn btn-primary">Publish Changes</a>
</div>

<!-- Summary Statistics -->
<div class="dashboard-stats">
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.domains|length }}</div>
        <div class="stat-label">Domains</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.routes|length }}</div>
        <div class="stat-label">Routes</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.dns_records|length }}</div>
        <div class="stat-label">DNS Records</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.gateway_servers|length }}</div>
        <div class="stat-label">Gateway Servers</div>
    </div>
</div>

<!-- Network Visualization -->
<div class="visualization-container">
    <h3>Network Visualization</h3>
    <div class="network-graph" id="networkGraph">
        <!-- SVG visualization will be rendered here -->
    </div>
</div>

<!-- Domain & Route Overview Table -->
<div class="overview-tables">
    <div class="table-container">
        <h3>Domain & Route Overview</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Domain</th>
                    <th>Subdomains</th>
                    <th>Routes</th>
                </tr>
            </thead>
            <tbody>
                {% for domain in visualization_data.domains %}
                <tr>
                    <td>{{ domain.name }}</td>
                    <td>
                        {% set matching_records = [] %}
                        {% for d in visualization_data.dns_records %}
                            {% if d.domain_id|int == domain.id|int %}
                                {% set _ = matching_records.append(d) %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_records|length }}</strong>
                    </td>
                    <td>
                        {% set matching_routes = [] %}
                        {% for r in visualization_data.routes %}
                            {% if r.domain_id|int == domain.id|int %}
                                {% set _ = matching_routes.append(r) %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_routes|length }}</strong>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    
    <div class="table-container">
        <h3>Gateway Overview</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Server</th>
                    <th>Clients</th>
                    <th>Connections</th>
                </tr>
            </thead>
            <tbody>
                {% for server in visualization_data.gateway_servers %}
                <tr>
                    <td>{{ server.name }} ({{ server.host }})</td>
                    <td>
                        {% set matching_clients = [] %}
                        {% for c in visualization_data.gateway_clients %}
                            {% if c.server_id|int == server.id|int %}
                                {% set _ = matching_clients.append(c) %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_clients|length }}</strong>
                    </td>
                    <td>
                        {% set matching_connections = [] %}
                        {% for client in visualization_data.gateway_clients %}
                            {% if client.server_id|int == server.id|int %}
                                {% for c in visualization_data.gateway_connections %}
                                    {% if c.client_id|int == client.id|int %}
                                        {% set _ = matching_connections.append(c) %}
                                    {% endif %}
                                {% endfor %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_connections|length }}</strong>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>

<!-- Visualization JavaScript -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Data passed from Python
    const visualizationData = {
        domains: {{ visualization_data.domains|tojson|safe }},
        routes: {{ visualization_data.routes|tojson|safe }},
        dnsRecords: {{ visualization_data.dns_records|tojson|safe }},
        gatewayServers: {{ visualization_data.gateway_servers|tojson|safe }},
        gatewayClients: {{ visualization_data.gateway_clients|tojson|safe }},
        gatewayConnections: {{ visualization_data.gateway_connections|tojson|safe }},
        localIp: {{ visualization_data.local_ip|tojson|safe }}
    };
    
    // Network graph container
    const container = document.getElementById('networkGraph');
    const width = container.clientWidth;
    const height = 500;
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    container.appendChild(svg);
    
    // Create nodes and links data
    const nodes = [];
    const links = [];
    
    // Add domain nodes with more strategic initial positioning
    const domainCount = visualizationData.domains.length;
    visualizationData.domains.forEach((domain, index) => {
        // Position domains in a circle in the center
        const angle = (index / domainCount) * 2 * Math.PI;
        const radius = Math.min(width, height) * 0.3;
        const x = width/2 + radius * Math.cos(angle);
        const y = height/2 + radius * Math.sin(angle);
        
        nodes.push({
            id: `domain-${domain.id}`,
            type: 'domain',
            name: domain.name,
            x: x,
            y: y,
            color: '#3498db'
        });
    });
    
    // Add route nodes and connect to domains
    visualizationData.routes.forEach(route => {
        // Convert IDs to numbers for consistent comparison
        const routeDomainId = parseInt(route.domain_id, 10);
        const routeId = `route-${route.id}`;
        const domainNode = `domain-${routeDomainId}`;
        
        // Find matching domain using numeric comparison
        const matchingDomain = visualizationData.domains.find(d => parseInt(d.id, 10) === routeDomainId);
        
        // Find the domain node for positioning routes around it
        const domainNodeIndex = nodes.findIndex(n => n.id === `domain-${routeDomainId}`);
        if (domainNodeIndex >= 0) {
            const domainNode = nodes[domainNodeIndex];
            // Calculate position near its domain with some randomness
            const angle = Math.random() * 2 * Math.PI;
            const distance = 60 + Math.random() * 40; // 60-100 pixels from domain
            nodes.push({
                id: routeId,
                type: 'route',
                name: `${route.subdomain}.${matchingDomain?.name || 'unknown'}`,
                x: domainNode.x + distance * Math.cos(angle),
                y: domainNode.y + distance * Math.sin(angle),
                color: '#2ecc71',
                domainId: routeDomainId  // Store for reference
            });
        } else {
            // Fallback if domain node not found
            nodes.push({
                id: routeId,
                type: 'route',
                name: `${route.subdomain}.${matchingDomain?.name || 'unknown'}`,
                x: width/2 + (Math.random() - 0.5) * width * 0.5,
                y: height/2 + (Math.random() - 0.5) * height * 0.5,
                color: '#2ecc71',
                domainId: routeDomainId  // Store for reference
            });
        }
        
        links.push({
            source: domainNode,
            target: routeId
        });
        
        // Add hosts and connect to routes
        if (route.hosts) {
            route.hosts.forEach(host => {
                const hostId = `host-${host.id}`;
                
                // Check if the host matches the local IP
                const isLocalHost = host.host.includes(visualizationData.localIp);
                
                // Find the route node for positioning hosts around it
                const routeNodeIndex = nodes.findIndex(n => n.id === routeId);
                if (routeNodeIndex >= 0) {
                    const routeNode = nodes[routeNodeIndex];
                    // Calculate position near its route with some randomness
                    const angle = Math.random() * 2 * Math.PI;
                    const distance = 50 + Math.random() * 30; // 50-80 pixels from route
                    nodes.push({
                        id: hostId,
                        type: 'host',
                        name: host.host,
                        x: routeNode.x + distance * Math.cos(angle),
                        y: routeNode.y + distance * Math.sin(angle),
                        color: isLocalHost ? '#e74c3c' : '#f39c12'
                    });
                } else {
                    // Fallback if route node not found
                    nodes.push({
                        id: hostId,
                        type: 'host',
                        name: host.host,
                        x: width/2 + (Math.random() - 0.5) * width * 0.5,
                        y: height/2 + (Math.random() - 0.5) * height * 0.5,
                        color: isLocalHost ? '#e74c3c' : '#f39c12'
                    });
                }
                
                links.push({
                    source: routeId,
                    target: hostId
                });
            });
        }
    });
    
    // Helper function to ensure valid number (avoid NaN)
    function ensureNumber(val, defaultVal = 0) {
        return (typeof val === 'number' && !isNaN(val)) ? val : defaultVal;
    }
    
    // Initialize all node positions if not already set
    nodes.forEach(node => {
        node.x = ensureNumber(node.x, Math.random() * width);
        node.y = ensureNumber(node.y, Math.random() * height);
    });
    
    // Function to create the visualization
    function createVisualization() {
        // Clear SVG
        svg.innerHTML = '';
        
        // Create links
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === link.source);
            const targetNode = nodes.find(n => n.id === link.target);
            
            if (sourceNode && targetNode) {
                // Ensure valid coordinates
                const x1 = ensureNumber(sourceNode.x);
                const y1 = ensureNumber(sourceNode.y);
                const x2 = ensureNumber(targetNode.x);
                const y2 = ensureNumber(targetNode.y);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#6c757d');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-opacity', '0.7');
                svg.appendChild(line);
            }
        });
        
        // Create nodes
        nodes.forEach(node => {
            // Ensure valid coordinates
            const x = ensureNumber(node.x);
            const y = ensureNumber(node.y);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${x}, ${y})`);
            g.setAttribute('data-id', node.id);
            
            // Create node circle with a glowing effect
            const glow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            glow.setAttribute('r', node.type === 'domain' ? 14 : 10);
            glow.setAttribute('fill', 'none');
            glow.setAttribute('stroke', node.color);
            glow.setAttribute('stroke-width', '2');
            glow.setAttribute('stroke-opacity', '0.5');
            glow.setAttribute('filter', 'blur(3px)');
            g.appendChild(glow);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', node.type === 'domain' ? 12 : 8);
            circle.setAttribute('fill', node.color);
            circle.setAttribute('stroke', '#ffffff');
            circle.setAttribute('stroke-width', '1');
            g.appendChild(circle);
            
            // Create text label with better contrast
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dy', '25');
            text.setAttribute('font-size', '12px');
            text.setAttribute('fill', '#ffffff');
            text.setAttribute('stroke', '#000000');
            text.setAttribute('stroke-width', '0.5');
            text.setAttribute('paint-order', 'stroke');
            text.textContent = node.name || node.id;
            g.appendChild(text);
            
            // Make nodes draggable
            let isDragging = false;
            let offset = { x: 0, y: 0 };
            
            g.addEventListener('mousedown', (e) => {
                e.preventDefault(); // Prevent text selection during drag
                isDragging = true;
                
                // Get SVG coordinates of the mouse event
                const svgPoint = getSVGCoordinates(svg, e.clientX, e.clientY);
                offset.x = svgPoint.x - node.x;
                offset.y = svgPoint.y - node.y;
                
                // Add dragging class for styling
                g.classList.add('dragging');
            });
            
            // Use one global event listener for mousemove
            if (!window._dragHandlerAttached) {
                window._dragHandlerAttached = true;
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    // Get SVG coordinates of the mouse event
                    const svgPoint = getSVGCoordinates(svg, e.clientX, e.clientY);
                    const draggedNodeId = e.target.closest('g')?.getAttribute('data-id');
                    
                    // Find the node being dragged
                    const draggedNode = nodes.find(n => n.id === draggedNodeId);
                    
                    if (draggedNode) {
                        draggedNode.x = ensureNumber(svgPoint.x - offset.x);
                        draggedNode.y = ensureNumber(svgPoint.y - offset.y);
                        
                        // Keep within bounds
                        draggedNode.x = Math.max(50, Math.min(width - 50, draggedNode.x));
                        draggedNode.y = Math.max(50, Math.min(height - 50, draggedNode.y));
                        
                        createVisualization();
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    document.querySelectorAll('.dragging').forEach(el => {
                        el.classList.remove('dragging');
                    });
                });
            }
            
            // Helper function to get SVG coordinates from client coordinates
            function getSVGCoordinates(svgElement, x, y) {
                const point = svgElement.createSVGPoint();
                point.x = x;
                point.y = y;
                
                // Convert to SVG coordinate system
                const ctm = svgElement.getScreenCTM();
                if (ctm) {
                    return point.matrixTransform(ctm.inverse());
                }
                
                // Fallback if getScreenCTM fails
                return { x, y };
            }
            
            svg.appendChild(g);
        });
    }
    
    // Initial creation
    createVisualization();
    
    // Advanced force simulation to create a well-distributed layout
    function applyForces() {
        // Apply repulsion force to separate nodes - stronger for different node types
        const baseRepulsion = 150; // Increased from 100
        const domainRepulsion = 200; // Domains need more space
        const attraction = 0.05; // Reduced from 0.1 for less bunching
        
        for (let i = 0; i < nodes.length; i++) {
            // Ensure nodes have valid positions
            nodes[i].x = ensureNumber(nodes[i].x, width / 2);
            nodes[i].y = ensureNumber(nodes[i].y, height / 2);
            
            for (let j = i + 1; j < nodes.length; j++) {
                // Ensure nodes have valid positions
                nodes[j].x = ensureNumber(nodes[j].x, width / 2);
                nodes[j].y = ensureNumber(nodes[j].y, height / 2);
                
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Use different repulsion strengths based on node types
                let repulsion = baseRepulsion;
                if (nodes[i].type === 'domain' || nodes[j].type === 'domain') {
                    repulsion = domainRepulsion; // Stronger repulsion for domains
                }
                
                if (dist > 0 && dist < repulsion) { // Avoid division by zero
                    // Quadratic force for more natural spacing
                    const force = (repulsion - dist) * (repulsion - dist) / (repulsion * dist);
                    nodes[i].x -= dx * force * 0.5;
                    nodes[i].y -= dy * force * 0.5;
                    nodes[j].x += dx * force * 0.5;
                    nodes[j].y += dy * force * 0.5;
                }
            }
        }
        
        // Apply attraction force for linked nodes
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === link.source);
            const targetNode = nodes.find(n => n.id === link.target);
            
            if (sourceNode && targetNode) {
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Ideal distance between connected nodes
                const idealDistance = 80;
                
                if (dist > 0) { // Avoid division by zero
                    // Only attract if distance is too large
                    if (dist > idealDistance) {
                        const force = (dist - idealDistance) * attraction / dist;
                        sourceNode.x += dx * force;
                        sourceNode.y += dy * force;
                        targetNode.x -= dx * force;
                        targetNode.y -= dy * force;
                    }
                }
            }
        });
        
        // Center force - gently pull nodes toward the center if they're far out
        const centerForce = 0.01;
        nodes.forEach(node => {
            const dx = width/2 - node.x;
            const dy = height/2 - node.y;
            const distFromCenter = Math.sqrt(dx*dx + dy*dy);
            
            if (distFromCenter > width/3) {
                node.x += dx * centerForce;
                node.y += dy * centerForce;
            }
        });
        
        // Keep nodes within bounds and ensure valid values with padding
        const padding = 80; // Increased from 50
        nodes.forEach(node => {
            node.x = Math.max(padding, Math.min(width - padding, ensureNumber(node.x, width/2)));
            node.y = Math.max(padding, Math.min(height - padding, ensureNumber(node.y, height/2)));
        });
        
        createVisualization();
    }
    
    // Distribute nodes in initial positions
    function initialLayout() {
        const domainCount = nodes.filter(n => n.type === 'domain').length;
        const angleStep = (2 * Math.PI) / Math.max(1, domainCount);
        
        // Position domains in a circle
        let domainIndex = 0;
        nodes.forEach(node => {
            if (node.type === 'domain') {
                const radius = Math.min(width, height) * 0.3;
                const angle = domainIndex * angleStep;
                node.x = width/2 + radius * Math.cos(angle);
                node.y = height/2 + radius * Math.sin(angle);
                domainIndex++;
            }
        });
        
        // Run force simulation gradually with damping
        let iteration = 0;
        const maxIterations = 60; // Increased from 30 for better stabilization
        
        function runSimulation() {
            if (iteration < maxIterations) {
                // Apply cooling factor to gradually reduce forces as simulation progresses
                const coolingFactor = 1 - (iteration / maxIterations); 
                
                // Modify force strength with cooling
                baseRepulsion = baseRepulsion * (0.9 + coolingFactor * 0.1);
                domainRepulsion = domainRepulsion * (0.9 + coolingFactor * 0.1);
                
                applyForces();
                iteration++;
                
                // Use slower animation frames for later iterations to let things settle
                const delay = Math.min(50, iteration / 2);
                setTimeout(runSimulation, delay);
            }
        }
        
        runSimulation();
    }
    
    // Start with a better layout
    initialLayout();
});
</script>

<style>
/* Dashboard Styling */
.dashboard-stats {
    display: flex;
    justify-content: space-around;
    flex-wrap: wrap;
    margin: 20px 0;
}

.stat-card {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    text-align: center;
    width: 150px;
    margin: 10px;
}

.stat-number {
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
}

.stat-label {
    color: #7f8c8d;
    margin-top: 5px;
}

.action-buttons {
    margin: 20px 0;
    text-align: center;
}

.visualization-container {
    margin: 30px 0;
    background-color: #2c3e50;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    color: #ffffff;
}

.network-graph {
    height: 500px;
    border: 1px solid #2c3e50;
    border-radius: 4px;
    background-color: #212529;
    color: #ffffff;
}

.overview-tables {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    margin: 20px 0;
}

.table-container {
    flex: 0 0 48%;
    margin-bottom: 20px;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
}

.data-table th, .data-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

.data-table th {
    background-color: #2c3e50;
    color: #ffffff;
    font-weight: bold;
}

.data-table tr:hover {
    background-color: #3a4d61;
    color: #ffffff;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .table-container {
        flex: 0 0 100%;
    }
}
</style>
{% endblock %}