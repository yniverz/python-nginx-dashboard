{% extends "_layout.jinja2" %}
{% block content %}
<h2>Welcome to the Multi-Domain Edge Manager!</h2>

<!-- Publish Button -->
<div class="action-buttons">
    <a href="{{ url_for('view_publish') }}" class="btn btn-primary">Publish Changes</a>
</div>

<!-- Summary Statistics -->
<div class="dashboard-stats">
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.domains|length }}</div>
        <div class="stat-label">Domains</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.routes|length }}</div>
        <div class="stat-label">Routes</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.dns_records|length }}</div>
        <div class="stat-label">DNS Records</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.gateway_servers|length }}</div>
        <div class="stat-label">Gateway Servers</div>
    </div>
</div>

<!-- Network Visualization -->
<div class="visualization-container">
    <h3>Network Visualization</h3>
    <div class="network-graph" id="networkGraph">
        <!-- SVG visualization will be rendered here -->
    </div>
</div>

<!-- Domain & Route Overview Table -->
<div class="overview-tables">
    <div class="table-container">
        <h3>Domain & Route Overview</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Domain</th>
                    <th>Subdomains</th>
                    <th>Routes</th>
                </tr>
            </thead>
            <tbody>
                {% for domain in visualization_data.domains %}
                <tr>
                    <td>{{ domain.name }}</td>
                    <td>
                        {% set subdomain_count = 0 %}
                        {% for d in visualization_data.dns_records %}
                            <!-- Convert both to string for comparison -->
                            {% if d.domain_id|string == domain.id|string %}
                                {% set subdomain_count = subdomain_count + 1 %}
                            {% endif %}
                        {% endfor %}
                        {{ subdomain_count }} record(s)
                    </td>
                    <td>
                        {% set route_count = 0 %}
                        {% for r in visualization_data.routes %}
                            <!-- Convert both to string for comparison -->
                            {% if r.domain_id|string == domain.id|string %}
                                {% set route_count = route_count + 1 %}
                            {% endif %}
                        {% endfor %}
                        {{ route_count }} route(s)
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    
    <div class="table-container">
        <h3>Gateway Overview</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Server</th>
                    <th>Clients</th>
                    <th>Connections</th>
                </tr>
            </thead>
            <tbody>
                {% for server in visualization_data.gateway_servers %}
                <tr>
                    <td>{{ server.name }} ({{ server.host }})</td>
                    <td>
                        {% set client_count = 0 %}
                        {% for c in visualization_data.gateway_clients %}
                            {% if c.server_id|string == server.id|string %}
                                {% set client_count = client_count + 1 %}
                            {% endif %}
                        {% endfor %}
                        {{ client_count }}
                    </td>
                    <td>
                        {% set conn_count = 0 %}
                        {% for client in visualization_data.gateway_clients %}
                            {% if client.server_id|string == server.id|string %}
                                {% for c in visualization_data.gateway_connections %}
                                    {% if c.client_id|string == client.id|string %}
                                        {% set conn_count = conn_count + 1 %}
                                    {% endif %}
                                {% endfor %}
                            {% endif %}
                        {% endfor %}
                        {{ conn_count }}
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>

<!-- Visualization JavaScript -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Data passed from Python
    const visualizationData = {
        domains: {{ visualization_data.domains|tojson|safe }},
        routes: {{ visualization_data.routes|tojson|safe }},
        dnsRecords: {{ visualization_data.dns_records|tojson|safe }},
        gatewayServers: {{ visualization_data.gateway_servers|tojson|safe }},
        gatewayClients: {{ visualization_data.gateway_clients|tojson|safe }},
        gatewayConnections: {{ visualization_data.gateway_connections|tojson|safe }},
        localIp: {{ visualization_data.local_ip|tojson|safe }}
    };
    
    // Network graph container
    const container = document.getElementById('networkGraph');
    const width = container.clientWidth;
    const height = 500;
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    container.appendChild(svg);
    
    // Create nodes and links data
    const nodes = [];
    const links = [];
    
    // Add domain nodes
    visualizationData.domains.forEach(domain => {
        nodes.push({
            id: `domain-${domain.id}`,
            type: 'domain',
            name: domain.name,
            x: Math.random() * width,
            y: Math.random() * height,
            color: '#3498db'
        });
    });
    
    // Add route nodes and connect to domains
    visualizationData.routes.forEach(route => {
        const domainNode = `domain-${route.domain_id}`;
        const routeId = `route-${route.id}`;
        
        nodes.push({
            id: routeId,
            type: 'route',
            name: `${route.subdomain}.${visualizationData.domains.find(d => String(d.id) === String(route.domain_id))?.name || ''}`,
            x: Math.random() * width,
            y: Math.random() * height,
            color: '#2ecc71'
        });
        
        links.push({
            source: domainNode,
            target: routeId
        });
        
        // Add hosts and connect to routes
        if (route.hosts) {
            route.hosts.forEach(host => {
                const hostId = `host-${host.id}`;
                
                // Check if the host matches the local IP
                const isLocalHost = host.host.includes(visualizationData.localIp);
                
                nodes.push({
                    id: hostId,
                    type: 'host',
                    name: host.host,
                    x: Math.random() * width,
                    y: Math.random() * height,
                    color: isLocalHost ? '#e74c3c' : '#f39c12'
                });
                
                links.push({
                    source: routeId,
                    target: hostId
                });
            });
        }
    });
    
    // Helper function to ensure valid number (avoid NaN)
    function ensureNumber(val, defaultVal = 0) {
        return (typeof val === 'number' && !isNaN(val)) ? val : defaultVal;
    }
    
    // Initialize all node positions if not already set
    nodes.forEach(node => {
        node.x = ensureNumber(node.x, Math.random() * width);
        node.y = ensureNumber(node.y, Math.random() * height);
    });
    
    // Function to create the visualization
    function createVisualization() {
        // Clear SVG
        svg.innerHTML = '';
        
        // Create links
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === link.source);
            const targetNode = nodes.find(n => n.id === link.target);
            
            if (sourceNode && targetNode) {
                // Ensure valid coordinates
                const x1 = ensureNumber(sourceNode.x);
                const y1 = ensureNumber(sourceNode.y);
                const x2 = ensureNumber(targetNode.x);
                const y2 = ensureNumber(targetNode.y);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#aaa');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            }
        });
        
        // Create nodes
        nodes.forEach(node => {
            // Ensure valid coordinates
            const x = ensureNumber(node.x);
            const y = ensureNumber(node.y);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${x}, ${y})`);
            g.setAttribute('data-id', node.id);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', node.type === 'domain' ? 12 : 8);
            circle.setAttribute('fill', node.color);
            g.appendChild(circle);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dy', '25');
            text.setAttribute('font-size', '12px');
            text.textContent = node.name || node.id;
            g.appendChild(text);
            
            // Make nodes draggable
            let isDragging = false;
            let offset = { x: 0, y: 0 };
            
            g.addEventListener('mousedown', (e) => {
                e.preventDefault(); // Prevent text selection during drag
                isDragging = true;
                
                // Get SVG coordinates of the mouse event
                const svgPoint = getSVGCoordinates(svg, e.clientX, e.clientY);
                offset.x = svgPoint.x - node.x;
                offset.y = svgPoint.y - node.y;
                
                // Add dragging class for styling
                g.classList.add('dragging');
            });
            
            // Use one global event listener for mousemove
            if (!window._dragHandlerAttached) {
                window._dragHandlerAttached = true;
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    // Get SVG coordinates of the mouse event
                    const svgPoint = getSVGCoordinates(svg, e.clientX, e.clientY);
                    const draggedNodeId = e.target.closest('g')?.getAttribute('data-id');
                    
                    // Find the node being dragged
                    const draggedNode = nodes.find(n => n.id === draggedNodeId);
                    
                    if (draggedNode) {
                        draggedNode.x = ensureNumber(svgPoint.x - offset.x);
                        draggedNode.y = ensureNumber(svgPoint.y - offset.y);
                        
                        // Keep within bounds
                        draggedNode.x = Math.max(50, Math.min(width - 50, draggedNode.x));
                        draggedNode.y = Math.max(50, Math.min(height - 50, draggedNode.y));
                        
                        createVisualization();
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    document.querySelectorAll('.dragging').forEach(el => {
                        el.classList.remove('dragging');
                    });
                });
            }
            
            // Helper function to get SVG coordinates from client coordinates
            function getSVGCoordinates(svgElement, x, y) {
                const point = svgElement.createSVGPoint();
                point.x = x;
                point.y = y;
                
                // Convert to SVG coordinate system
                const ctm = svgElement.getScreenCTM();
                if (ctm) {
                    return point.matrixTransform(ctm.inverse());
                }
                
                // Fallback if getScreenCTM fails
                return { x, y };
            }
            
            svg.appendChild(g);
        });
    }
    
    // Initial creation
    createVisualization();
    
    // Simple force simulation to prevent overlap
    function applyForces() {
        const repulsion = 100;
        const attraction = 0.1;
        
        for (let i = 0; i < nodes.length; i++) {
            // Ensure nodes have valid positions
            nodes[i].x = ensureNumber(nodes[i].x, width / 2);
            nodes[i].y = ensureNumber(nodes[i].y, height / 2);
            
            for (let j = i + 1; j < nodes.length; j++) {
                // Ensure nodes have valid positions
                nodes[j].x = ensureNumber(nodes[j].x, width / 2);
                nodes[j].y = ensureNumber(nodes[j].y, height / 2);
                
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0 && dist < repulsion) { // Avoid division by zero
                    const force = (repulsion - dist) / dist;
                    nodes[i].x -= dx * force * 0.5;
                    nodes[i].y -= dy * force * 0.5;
                    nodes[j].x += dx * force * 0.5;
                    nodes[j].y += dy * force * 0.5;
                }
            }
        }
        
        // Apply attraction force for linked nodes
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === link.source);
            const targetNode = nodes.find(n => n.id === link.target);
            
            if (sourceNode && targetNode) {
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) { // Avoid division by zero
                    const force = dist * attraction;
                    
                    sourceNode.x += dx * force;
                    sourceNode.y += dy * force;
                    targetNode.x -= dx * force;
                    targetNode.y -= dy * force;
                }
            }
        });
        
        // Keep nodes within bounds and ensure valid values
        nodes.forEach(node => {
            node.x = Math.max(50, Math.min(width - 50, ensureNumber(node.x, width/2)));
            node.y = Math.max(50, Math.min(height - 50, ensureNumber(node.y, height/2)));
        });
        
        createVisualization();
    }
    
    // Distribute nodes in initial positions
    function initialLayout() {
        const domainCount = nodes.filter(n => n.type === 'domain').length;
        const angleStep = (2 * Math.PI) / Math.max(1, domainCount);
        
        // Position domains in a circle
        let domainIndex = 0;
        nodes.forEach(node => {
            if (node.type === 'domain') {
                const radius = Math.min(width, height) * 0.3;
                const angle = domainIndex * angleStep;
                node.x = width/2 + radius * Math.cos(angle);
                node.y = height/2 + radius * Math.sin(angle);
                domainIndex++;
            }
        });
        
        // Run force simulation gradually with damping
        let iteration = 0;
        const maxIterations = 30;
        
        function runSimulation() {
            if (iteration < maxIterations) {
                applyForces();
                iteration++;
                requestAnimationFrame(runSimulation);
            }
        }
        
        runSimulation();
    }
    
    // Start with a better layout
    initialLayout();
});
</script>

<style>
/* Dashboard Styling */
.dashboard-stats {
    display: flex;
    justify-content: space-around;
    flex-wrap: wrap;
    margin: 20px 0;
}

.stat-card {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    text-align: center;
    width: 150px;
    margin: 10px;
}

.stat-number {
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
}

.stat-label {
    color: #7f8c8d;
    margin-top: 5px;
}

.action-buttons {
    margin: 20px 0;
    text-align: center;
}

.visualization-container {
    margin: 30px 0;
    background-color: #f8f9fa;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.network-graph {
    height: 500px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: white;
}

.overview-tables {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    margin: 20px 0;
}

.table-container {
    flex: 0 0 48%;
    margin-bottom: 20px;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
}

.data-table th, .data-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

.data-table th {
    background-color: #f2f2f2;
    font-weight: bold;
}

.data-table tr:hover {
    background-color: #f5f5f5;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .table-container {
        flex: 0 0 100%;
    }
}
</style>
{% endblock %}