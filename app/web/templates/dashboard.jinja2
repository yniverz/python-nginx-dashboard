{% extends "_layout.jinja2" %}
{% block content %}
<h2>Welcome to the Multi-Domain Edge Manager!</h2>

<!-- Publish Button -->
<div class="action-buttons">
    <a href="{{ url_for('view_publish') }}" class="btn btn-primary">Publish Changes</a>
</div>

<!-- Summary Statistics -->
<div class="dashboard-stats">
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.domains|length }}</div>
        <div class="stat-label">Domains</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.routes|length }}</div>
        <div class="stat-label">Routes</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.dns_records|length }}</div>
        <div class="stat-label">DNS Records</div>
    </div>
    <div class="stat-card">
        <div class="stat-number">{{ visualization_data.gateway_servers|length }}</div>
        <div class="stat-label">Gateway Servers</div>
    </div>
</div>

<!-- Network Visualization -->
<div class="visualization-container">
    <h3>Network Visualization</h3>
    <div class="network-graph" id="networkGraph">
        <!-- SVG visualization will be rendered here -->
    </div>
</div>

<!-- Domain & Route Overview Table -->
<div class="overview-tables">
    <div class="table-container">
        <h3>Domain & Route Overview</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Domain</th>
                    <th>Subdomains</th>
                    <th>Routes</th>
                </tr>
            </thead>
            <tbody>
                {% for domain in visualization_data.domains %}
                <tr>
                    <td>{{ domain.name }}</td>
                    <td>
                        {% set matching_records = [] %}
                        {% for d in visualization_data.dns_records %}
                            {% if d.domain_id|int == domain.id|int %}
                                {% set _ = matching_records.append(d) %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_records|length }}</strong>
                    </td>
                    <td>
                        {% set matching_routes = [] %}
                        {% for r in visualization_data.routes %}
                            {% if r.domain_id|int == domain.id|int %}
                                {% set _ = matching_routes.append(r) %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_routes|length }}</strong>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    
    <div class="table-container">
        <h3>Gateway Overview</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Server</th>
                    <th>Clients</th>
                    <th>Connections</th>
                </tr>
            </thead>
            <tbody>
                {% for server in visualization_data.gateway_servers %}
                <tr>
                    <td>{{ server.name }} ({{ server.host }})</td>
                    <td>
                        {% set matching_clients = [] %}
                        {% for c in visualization_data.gateway_clients %}
                            {% if c.server_id|int == server.id|int %}
                                {% set _ = matching_clients.append(c) %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_clients|length }}</strong>
                    </td>
                    <td>
                        {% set matching_connections = [] %}
                        {% for client in visualization_data.gateway_clients %}
                            {% if client.server_id|int == server.id|int %}
                                {% for c in visualization_data.gateway_connections %}
                                    {% if c.client_id|int == client.id|int %}
                                        {% set _ = matching_connections.append(c) %}
                                    {% endif %}
                                {% endfor %}
                            {% endif %}
                        {% endfor %}
                        <strong>{{ matching_connections|length }}</strong>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>

<!-- Visualization JavaScript -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Data passed from Python
    const visualizationData = {
        domains: {{ visualization_data.domains|tojson|safe }},
        routes: {{ visualization_data.routes|tojson|safe }},
        dnsRecords: {{ visualization_data.dns_records|tojson|safe }},
        gatewayServers: {{ visualization_data.gateway_servers|tojson|safe }},
        gatewayClients: {{ visualization_data.gateway_clients|tojson|safe }},
        gatewayConnections: {{ visualization_data.gateway_connections|tojson|safe }},
        localIp: {{ visualization_data.local_ip|tojson|safe }}
    };
    
    // Network graph container
    const container = document.getElementById('networkGraph');
    const width = container.clientWidth;
    const height = 500;
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    container.appendChild(svg);
    
    // Create nodes and links data
    const nodes = [];
    const links = [];
    
    // Add domain nodes with more strategic initial positioning
    const domainCount = visualizationData.domains.length;
    visualizationData.domains.forEach((domain, index) => {
        // Position domains in a circle in the center
        const angle = (index / domainCount) * 2 * Math.PI;
        const radius = Math.min(width, height) * 0.3;
        const x = width/2 + radius * Math.cos(angle);
        const y = height/2 + radius * Math.sin(angle);
        
        nodes.push({
            id: `domain-${domain.id}`,
            type: 'domain',
            name: domain.name,
            x: x,
            y: y,
            color: '#3498db'
        });
    });
    
    // Add route nodes and connect to domains
    visualizationData.routes.forEach(route => {
        // Convert IDs to numbers for consistent comparison
        const routeDomainId = parseInt(route.domain_id, 10);
        const routeId = `route-${route.id}`;
        const domainNode = `domain-${routeDomainId}`;
        
        // Find matching domain using numeric comparison
        const matchingDomain = visualizationData.domains.find(d => parseInt(d.id, 10) === routeDomainId);
        
        // Find the domain node for positioning routes around it
        const domainNodeIndex = nodes.findIndex(n => n.id === `domain-${routeDomainId}`);
        if (domainNodeIndex >= 0) {
            const domainNode = nodes[domainNodeIndex];
            // Calculate position near its domain with some randomness
            const angle = Math.random() * 2 * Math.PI;
            const distance = 60 + Math.random() * 40; // 60-100 pixels from domain
            nodes.push({
                id: routeId,
                type: 'route',
                name: `${route.subdomain}.${matchingDomain?.name || 'unknown'}`,
                x: domainNode.x + distance * Math.cos(angle),
                y: domainNode.y + distance * Math.sin(angle),
                color: '#2ecc71',
                domainId: routeDomainId  // Store for reference
            });
        } else {
            // Fallback if domain node not found
            nodes.push({
                id: routeId,
                type: 'route',
                name: `${route.subdomain}.${matchingDomain?.name || 'unknown'}`,
                x: width/2 + (Math.random() - 0.5) * width * 0.5,
                y: height/2 + (Math.random() - 0.5) * height * 0.5,
                color: '#2ecc71',
                domainId: routeDomainId  // Store for reference
            });
        }
        
        links.push({
            source: domainNode,
            target: routeId
        });
        
        // Add hosts and connect to routes
        if (route.hosts) {
            route.hosts.forEach(host => {
                const hostId = `host-${host.id}`;
                
                // Check if the host matches the local IP
                const isLocalHost = host.host.includes(visualizationData.localIp);
                
                // Find the route node for positioning hosts around it
                const routeNodeIndex = nodes.findIndex(n => n.id === routeId);
                if (routeNodeIndex >= 0) {
                    const routeNode = nodes[routeNodeIndex];
                    // Calculate position near its route with some randomness
                    const angle = Math.random() * 2 * Math.PI;
                    const distance = 50 + Math.random() * 30; // 50-80 pixels from route
                    nodes.push({
                        id: hostId,
                        type: 'host',
                        name: host.host,
                        x: routeNode.x + distance * Math.cos(angle),
                        y: routeNode.y + distance * Math.sin(angle),
                        color: isLocalHost ? '#e74c3c' : '#f39c12'
                    });
                } else {
                    // Fallback if route node not found
                    nodes.push({
                        id: hostId,
                        type: 'host',
                        name: host.host,
                        x: width/2 + (Math.random() - 0.5) * width * 0.5,
                        y: height/2 + (Math.random() - 0.5) * height * 0.5,
                        color: isLocalHost ? '#e74c3c' : '#f39c12'
                    });
                }
                
                links.push({
                    source: routeId,
                    target: hostId
                });
            });
        }
    });
    
    // Helper function to ensure valid number (avoid NaN)
    function ensureNumber(val, defaultVal = 0) {
        return (typeof val === 'number' && !isNaN(val)) ? val : defaultVal;
    }
    
    // Initialize all node positions if not already set
    nodes.forEach(node => {
        node.x = ensureNumber(node.x, Math.random() * width);
        node.y = ensureNumber(node.y, Math.random() * height);
    });
    
    // Create map of nodes by ID for faster lookups
    const nodeMap = {};
    nodes.forEach(node => {
        nodeMap[node.id] = node;
    });
    
    // Function to create the visualization with performance optimizations
    function createVisualization() {
        // Clear SVG - more efficient than innerHTML = ''
        while (svg.firstChild) {
            svg.removeChild(svg.firstChild);
        }
        
        // Create all lines first for better performance
        const linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        linesGroup.setAttribute('class', 'links-group');
        
        // Create links
        links.forEach(link => {
            const sourceNode = nodeMap[link.source];
            const targetNode = nodeMap[link.target];
            
            if (sourceNode && targetNode) {
                // Ensure valid coordinates
                const x1 = ensureNumber(sourceNode.x);
                const y1 = ensureNumber(sourceNode.y);
                const x2 = ensureNumber(targetNode.x);
                const y2 = ensureNumber(targetNode.y);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#6c757d');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-opacity', '0.7');
                line.setAttribute('stroke-linecap', 'round');
                linesGroup.appendChild(line);
            }
        });
        
        // Add all lines at once
        svg.appendChild(linesGroup);
        
        // Create nodes in a single group for better performance
        const nodesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        nodesGroup.setAttribute('class', 'nodes-group');
        
        // Create a reusable function for node creation to improve performance
        function createNodeElement(node) {
            // Ensure valid coordinates
            const x = ensureNumber(node.x);
            const y = ensureNumber(node.y);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${x}, ${y})`);
            g.setAttribute('data-id', node.id);
            g.setAttribute('class', `node-${node.type}`);
            
            // Create node circle with a glow effect using a more efficient approach
            // First create a larger background circle
            const background = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            background.setAttribute('r', node.type === 'domain' ? 15 : 11);
            background.setAttribute('fill', node.color);
            background.setAttribute('opacity', '0.3');
            g.appendChild(background);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', node.type === 'domain' ? 12 : 8);
            circle.setAttribute('fill', node.color);
            circle.setAttribute('stroke', '#ffffff');
            circle.setAttribute('stroke-width', '1');
            g.appendChild(circle);
            
            // Only create text if we actually have a name (improved performance)
            if (node.name) {
                // Create text label with better contrast
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '25');
                text.setAttribute('font-size', '12px');
                text.setAttribute('fill', '#ffffff');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('stroke', '#000000');
                text.setAttribute('stroke-width', '0.5');
                text.setAttribute('paint-order', 'stroke');
                text.textContent = node.name;
                g.appendChild(text);
            }
            
            return g;
        }
        
        // Process nodes by type for better visual layering
        // First process non-domains (routes, hosts, etc)
        nodes.filter(node => node.type !== 'domain').forEach(node => {
            const nodeElement = createNodeElement(node);
            nodesGroup.appendChild(nodeElement);
        });
        
        // Then process domains so they appear on top
        nodes.filter(node => node.type === 'domain').forEach(node => {
            const nodeElement = createNodeElement(node);
            nodesGroup.appendChild(nodeElement);
        });
        // Add the nodes group to the SVG
        svg.appendChild(nodesGroup);
        
        // Set up dragging behavior for all nodes at once
        const allNodeElements = nodesGroup.querySelectorAll('g');
        allNodeElements.forEach(nodeElement => {
            const nodeId = nodeElement.getAttribute('data-id');
            const node = nodeMap[nodeId];
            
            // Store node reference for quick access
            nodeElement.node = node;
            
            // Add drag start listener
            nodeElement.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Set global dragging state
                window._currentDragNode = node;
                
                // Get SVG coordinates of the mouse event
                const svgPoint = getSVGCoordinates(svg, e.clientX, e.clientY);
                window._dragOffset = {
                    x: svgPoint.x - node.x,
                    y: svgPoint.y - node.y
                };
                
                // Add dragging class for styling
                nodeElement.classList.add('dragging');
            });
        });
            
        // Set up global drag handlers if not already done
        if (!window._dragHandlerAttached) {
            window._dragHandlerAttached = true;
            window._isDragging = false;
            
            // Throttle function to limit how often a function can run
            function throttle(callback, limit) {
                let waiting = false;
                return function() {
                    if (!waiting) {
                        callback.apply(this, arguments);
                        waiting = true;
                        setTimeout(function() {
                            waiting = false;
                        }, limit);
                    }
                };
            }
            
            // Throttled version of createVisualization for better performance
            const throttledUpdate = throttle(function() {
                // Only update node positions without full re-render
                document.querySelectorAll('.nodes-group g').forEach(nodeEl => {
                    const node = nodeEl.node;
                    if (node) {
                        nodeEl.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                    }
                });
                
                // Update lines
                const lines = document.querySelectorAll('.links-group line');
                links.forEach((link, index) => {
                    if (index < lines.length) {
                        const sourceNode = nodeMap[link.source];
                        const targetNode = nodeMap[link.target];
                        if (sourceNode && targetNode) {
                            lines[index].setAttribute('x1', sourceNode.x);
                            lines[index].setAttribute('y1', sourceNode.y);
                            lines[index].setAttribute('x2', targetNode.x);
                            lines[index].setAttribute('y2', targetNode.y);
                        }
                    }
                });
            }, 30);  // 30ms throttle for smoother performance
            
            // Global mousemove handler with throttling
            document.addEventListener('mousemove', (e) => {
                // Only process if we have a node being dragged
                if (!window._currentDragNode) return;
                
                window._isDragging = true;
                
                // Get SVG coordinates of the mouse event
                const svgPoint = getSVGCoordinates(svg, e.clientX, e.clientY);
                const draggedNode = window._currentDragNode;
                
                if (draggedNode) {
                    // Calculate new position with the stored offset
                    draggedNode.x = ensureNumber(svgPoint.x - window._dragOffset.x);
                    draggedNode.y = ensureNumber(svgPoint.y - window._dragOffset.y);
                    
                    // Keep within bounds with more padding
                    const padding = 80;
                    draggedNode.x = Math.max(padding, Math.min(width - padding, draggedNode.x));
                    draggedNode.y = Math.max(padding, Math.min(height - padding, draggedNode.y));
                    
                    // Update only node positions without full re-render
                    throttledUpdate();
                }
            });
            
            // Global mouseup handler
            document.addEventListener('mouseup', () => {
                // Only process if we were dragging
                if (window._currentDragNode) {
                    // A full re-render once dragging ends
                    createVisualization();
                }
                
                // Clear dragging state
                window._currentDragNode = null;
                window._dragOffset = null;
                window._isDragging = false;
                
                // Remove visual indicators
                document.querySelectorAll('.dragging').forEach(el => {
                    el.classList.remove('dragging');
                });
            });
        }
        
        // Helper function to get SVG coordinates from client coordinates
        function getSVGCoordinates(svgElement, x, y) {
            const point = svgElement.createSVGPoint();
            point.x = x;
            point.y = y;
            
            // Convert to SVG coordinate system
            const ctm = svgElement.getScreenCTM();
            if (ctm) {
                return point.matrixTransform(ctm.inverse());
            }
            
            // Fallback if getScreenCTM fails
            return { x, y };
        }
    }
    
    // Initial creation
    createVisualization();
    
    // Advanced force simulation to create a well-distributed layout
    function applyForces() {
        // Apply repulsion force to separate nodes - with reduced strength for stability
        const baseRepulsion = 80; // Reduced from 150 to make movement less aggressive
        const domainRepulsion = 120; // Reduced from 200 to make movement less aggressive
        const attraction = 0.02; // Reduced from 0.05 for gentler forces
        
        for (let i = 0; i < nodes.length; i++) {
            // Ensure nodes have valid positions
            nodes[i].x = ensureNumber(nodes[i].x, width / 2);
            nodes[i].y = ensureNumber(nodes[i].y, height / 2);
            
            for (let j = i + 1; j < nodes.length; j++) {
                // Ensure nodes have valid positions
                nodes[j].x = ensureNumber(nodes[j].x, width / 2);
                nodes[j].y = ensureNumber(nodes[j].y, height / 2);
                
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Use different repulsion strengths based on node types
                let repulsion = baseRepulsion;
                if (nodes[i].type === 'domain' || nodes[j].type === 'domain') {
                    repulsion = domainRepulsion; // Stronger repulsion for domains
                }
                
                if (dist > 0 && dist < repulsion) { // Avoid division by zero
                    // Use a gentler force calculation with damping
                    const force = Math.min(5, (repulsion - dist) / dist * 0.3);
                    nodes[i].x -= dx * force * 0.5;
                    nodes[i].y -= dy * force * 0.5;
                    nodes[j].x += dx * force * 0.5;
                    nodes[j].y += dy * force * 0.5;
                }
            }
        }
        
        // Apply attraction force for linked nodes
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === link.source);
            const targetNode = nodes.find(n => n.id === link.target);
            
            if (sourceNode && targetNode) {
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Ideal distance between connected nodes
                const idealDistance = 80;
                
                if (dist > 0) { // Avoid division by zero
                    // Only attract if distance is too large, with a gentler force
                    if (dist > idealDistance) {
                        // Apply a maximum force cap to prevent wild movements
                        const force = Math.min(0.2, (dist - idealDistance) * attraction / dist);
                        sourceNode.x += dx * force;
                        sourceNode.y += dy * force;
                        targetNode.x -= dx * force;
                        targetNode.y -= dy * force;
                    }
                }
            }
        });
        
        // Center force - very gently pull nodes toward the center if they're far out
        const centerForce = 0.005; // Reduced from 0.01 for gentler centering
        nodes.forEach(node => {
            const dx = width/2 - node.x;
            const dy = height/2 - node.y;
            const distFromCenter = Math.sqrt(dx*dx + dy*dy);
            
            if (distFromCenter > width/3) {
                // Apply center force with distance-based scaling
                const scaledForce = centerForce * (distFromCenter - width/3) / width;
                node.x += dx * scaledForce;
                node.y += dy * scaledForce;
            }
        });
        
        // Keep nodes within bounds and ensure valid values with padding
        const padding = 80; // Increased from 50
        nodes.forEach(node => {
            node.x = Math.max(padding, Math.min(width - padding, ensureNumber(node.x, width/2)));
            node.y = Math.max(padding, Math.min(height - padding, ensureNumber(node.y, height/2)));
        });
        
        createVisualization();
    }
    
    // Distribute nodes in initial positions
    function initialLayout() {
        const domainCount = nodes.filter(n => n.type === 'domain').length;
        const angleStep = (2 * Math.PI) / Math.max(1, domainCount);
        
        // Position domains in a circle
        let domainIndex = 0;
        nodes.forEach(node => {
            if (node.type === 'domain') {
                const radius = Math.min(width, height) * 0.3;
                const angle = domainIndex * angleStep;
                node.x = width/2 + radius * Math.cos(angle);
                node.y = height/2 + radius * Math.sin(angle);
                domainIndex++;
            }
        });
        
        // Perform initial layout with fixed number of iterations instead of animation
        // This is much more efficient as it does all calculations at once
        for (let i = 0; i < 20; i++) {
            applyForces();
        }
        
        // Final visualization after initial forces are applied
        createVisualization();
        
        // Set up lightweight animation for responsiveness during interaction
        setupInteractiveForces();
    }
    
    // Set up interaction forces that only run when needed
    function setupInteractiveForces() {
        // We'll use requestAnimationFrame for smoother animation
        let animationFrameId = null;
        let lastInteractionTime = Date.now();
        const interactionTimeout = 2000; // Stop animation 2 seconds after last interaction
        
        // Function to apply forces and schedule next frame if needed
        function animateForces() {
            // Check if we should stop animation (no recent interaction)
            if (Date.now() - lastInteractionTime > interactionTimeout) {
                animationFrameId = null;
                return;
            }
            
            // Apply a single iteration of forces
            applyForces();
            
            // Update visualization
            createVisualization();
            
            // Schedule next frame
            animationFrameId = requestAnimationFrame(animateForces);
        }
        
        // Start animation when a node is dragged
        document.addEventListener('mousemove', function() {
            if (window._currentDragNode) {
                // Update last interaction time
                lastInteractionTime = Date.now();
                
                // Start animation if not already running
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(animateForces);
                }
            }
        });
        
        // Also start animation when a node is released
        document.addEventListener('mouseup', function() {
            if (window._isDragging) {
                // Update last interaction time
                lastInteractionTime = Date.now();
                
                // Start animation if not already running
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(animateForces);
                }
            }
        });
    }
    
    // Start with a better layout
    initialLayout();
});
</script>

<style>
/* Dashboard Styling */
.dashboard-stats {
    display: flex;
    justify-content: space-around;
    flex-wrap: wrap;
    margin: 20px 0;
}

/* Network Graph Dragging Styles */
.dragging {
    cursor: grabbing !important;
}

g {
    cursor: grab;
}

g circle {
    transition: stroke-width 0.2s, stroke-opacity 0.2s;
}

g:hover circle {
    stroke-width: 2px;
    stroke-opacity: 1;
}

.stat-card {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    text-align: center;
    width: 150px;
    margin: 10px;
}

.stat-number {
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
}

.stat-label {
    color: #7f8c8d;
    margin-top: 5px;
}

.action-buttons {
    margin: 20px 0;
    text-align: center;
}

.visualization-container {
    margin: 30px 0;
    background-color: #2c3e50;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    color: #ffffff;
}

.network-graph {
    height: 500px;
    border: 1px solid #2c3e50;
    border-radius: 4px;
    background-color: #212529;
    color: #ffffff;
}

.overview-tables {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    margin: 20px 0;
}

.table-container {
    flex: 0 0 48%;
    margin-bottom: 20px;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
}

.data-table th, .data-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

.data-table th {
    background-color: #2c3e50;
    color: #ffffff;
    font-weight: bold;
}

.data-table tr:hover {
    background-color: #3a4d61;
    color: #ffffff;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .table-container {
        flex: 0 0 100%;
    }
}
</style>
{% endblock %}