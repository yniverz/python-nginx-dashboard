import os
import subprocess
from typing import Dict, List
from app.config import settings
from app.models import Domain, HttpRoute, StreamRoute, CertBundle

HTTP_HEADER = """# generated by multi-domain-proxy (HTTP)
proxy_http_version 1.1;
"""

STREAM_HEADER = """# generated by multi-domain-proxy (STREAM)
"""

class NginxService:
    def __init__(self, http_conf_path: str|None=None, stream_conf_path: str|None=None):
        self.http_conf_path = http_conf_path or settings.NGINX_HTTP_CONF
        self.stream_conf_path = stream_conf_path or settings.NGINX_STREAM_CONF

    def render_http(self, domains: List[Domain], routes_by_domain: Dict[int, List[HttpRoute]], certs: Dict[int, CertBundle]) -> str:
        out = [HTTP_HEADER]
        for d in domains:
            cert = certs.get(d.id)
            if not cert:
                # create an HTTP-only server block to catch http until cert is ready
                server_block = f"""
server {{
    listen 80;
    server_name {d.name} *.{d.name};
    return 301 https://$host$request_uri;
}}
"""
                out.append(server_block)
                continue

            # one server block per fqdn (subdomains in routes), plus wildcard fallback
            names = set()
            names.add(d.name)
            for r in routes_by_domain.get(d.id, []):
                fqdn = d.name if r.subdomain in ("@", "",) else f"{r.subdomain}.{d.name}"
                names.add(fqdn)

            server_block = f"""
server {{
    listen 443 ssl http2;
    server_name {' '.join(sorted(names))};

    ssl_certificate     {cert.fullchain_path};
    ssl_certificate_key {cert.privkey_path};

    # default location returns 404 to unknown subdomains if routed here
    location / {{ return 404; }}
}}
"""
            out.append(server_block)

            # per-route location proxy (emit specific server blocks for simple isolation)
            for r in routes_by_domain.get(d.id, []):
                fqdn = d.name if r.subdomain in ("@", "",) else f"{r.subdomain}.{d.name}"
                block = f"""
server {{
    listen 443 ssl http2;
    server_name {fqdn};

    ssl_certificate     {cert.fullchain_path};
    ssl_certificate_key {cert.privkey_path};

    location / {{
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_pass {r.backend_url};
    }}
}}
"""
                out.append(block)
        return "\n".join(out)

    def render_stream(self, domains: List[Domain], routes_by_domain: Dict[int, List[StreamRoute]]) -> str:
        out = [STREAM_HEADER, "stream {"]  # nginx expects stream{...} in a file loaded from main
        for d in domains:
            for r in routes_by_domain.get(d.id, []):
                fqdn = d.name if r.subdomain in ("@", "",) else f"{r.subdomain}.{d.name}"
                block = f"""
    # {fqdn}
    server {{
        listen {r.port};
        proxy_pass {r.target};
    }}
"""
                out.append(block)
        out.append("}")
        return "\n".join(out)

    def write_and_reload(self, http_conf: str, stream_conf: str):
        with open(self.http_conf_path, "w") as f: f.write(http_conf)
        with open(self.stream_conf_path, "w") as f: f.write(stream_conf)
        # test and reload
        try:
            subprocess.run([settings.NGINX_CMD, "-t"], check=True, capture_output=True)
            subprocess.run(settings.NGINX_RELOAD_CMD.split(), check=True)
        except Exception as e:
            print("nginx reload failed:", e)
